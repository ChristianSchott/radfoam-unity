#pragma kernel BuildAdjDiff
#pragma kernel RadFoam

#pragma multi_compile_local _ SH_DEGREE_1 SH_DEGREE_2 SH_DEGREE_3 

#include "UnityCG.cginc"
#include "sh_utils.cginc"

float _FisheyeFOV;
float4x4 _Camera2WorldMatrix;
float4x4 _InverseProjectionMatrix;

Texture2D<float> _CameraDepth;
Texture2D<float4> _srcTex;
RWTexture2D<float4> _outTex;

float2 GetPixelCoords(uint2 id)
{
    uint w, h;
    _outTex.GetDimensions(w, h);
    return id / float2(w, h) * 2 - 1;
}

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray GetCameraRay(float2 pixelCoords)
{
    Ray o;
    o.origin       = mul(_Camera2WorldMatrix, float4(0,0,0,1)).xyz; 
    float3 fragPos = mul(_InverseProjectionMatrix, float4(pixelCoords,0,1)).xyz; 
    o.direction    = mul(_Camera2WorldMatrix, float4(fragPos,0)).xyz ;
    return o;
}

static const float PI = 3.14159265f;
Ray GetCameraRayFisheye(float2 uv, float fov)
{
    Ray o;
    o.origin       = mul(_Camera2WorldMatrix, float4(0,0,0,1)).xyz;

    float theta = atan2(uv.y, uv.x);
    float phi = sqrt(dot(uv, uv)) * fov * (1.0 / 360.0) * 2 * PI;
    float3 local_dir = sin(phi) * cos(theta) * float3(1, 0, 0) 
                    + sin(phi) * sin(theta) * float3(0, 1, 0) 
                    + cos(phi) *  float3(0, 0, -1);
    o.direction = mul(_Camera2WorldMatrix, float4(local_dir, 0)).xyz;
    if (phi >= PI) {
        o.direction = (float3)0;
    }
    return o;
}

#define CHUNK_SIZE 4

struct SH {
    float harmonics[SH_DIM * 3]; // TODO: compress..
};

StructuredBuffer<uint> _start_index;
StructuredBuffer<float4> _positions;
StructuredBuffer<float4> _attributes;
StructuredBuffer<SH> _shs;
StructuredBuffer<uint> _adjacency_offset;
StructuredBuffer<uint> _adjacency;
StructuredBuffer<half4> _adjacency_diff;


[numthreads(8, 8, 1)]
void RadFoam (uint3 id : SV_DispatchThreadID)
{
    Ray ray;
    {
        uint w, h;
        _outTex.GetDimensions(w, h);
        if (id.x > w || id.y > h)
            return;

        float aspect_ratio = (float)w / (float)h;
        float x = id.x / (float)w;
        float y = id.y / (float)h;
        
        float2 pixelCoords = id.xy / float2(w, h) * 2 - 1;

        float2 uv = float2((2.0f * x - 1.0f) * aspect_ratio,  2.0f * y - 1.0f);

        ray = GetCameraRayFisheye(uv, _FisheyeFOV);
    }
    float4 src_color = _srcTex[id.xy];
    if (dot(ray.direction, ray.direction) == 0) {
        _outTex[id.xy] = src_color;
        return; // fisheye fov too large
    }

    float scene_depth = LinearEyeDepth(_CameraDepth[id.xy]);

    //ray.direction = normalize(ray.direction);
    float sh_coeffs[SH_DIM];
    sh_coefficients(ray.direction, sh_coeffs);

    float4 diffs[CHUNK_SIZE];

    // tracing state
    uint cell = _start_index[0];

    float transmittance = 1.0f;
    float3 color = float3(0, 0, 0);
    float t_0 = 0.0f;

    for (int i = 0; i < 256 && transmittance > 0.001; i++) {
        float4 cell_pos = _positions[cell];
        uint adj_from = cell > 0 ? _adjacency_offset[cell - 1] : 0;
        uint adj_to = _adjacency_offset[cell];

        float t_1 = scene_depth;
        uint next_face = 0xFFFFFFFF; 

        for (uint c = adj_from; c < adj_to; c += CHUNK_SIZE) {

            [unroll]
            for (uint a1 = 0; a1 < CHUNK_SIZE; a1++) {
                diffs[a1] = (float4)_adjacency_diff[c + a1];
            }

            [unroll]
            for (uint a2 = 0; a2 < CHUNK_SIZE; a2++) {
                float3 diff = diffs[a2].xyz;
                float denom = dot(diff, ray.direction);
                float3 mid = cell_pos.xyz + diff * 0.5f;
                float t = dot(mid - ray.origin, diff) / denom;
                if (denom > 0.0f && t < t_1 && t > t_0 && c + a2 < adj_to) {
                    t_1 = t;
                    next_face = c + a2;
                }
            }
        }

        if (next_face == 0xFFFFFFFF) {
            break;
        }

        float alpha = 1.0 - exp(-cell_pos.w * (t_1 - t_0));
        float weight = transmittance * alpha;

        // float3 rgb = cell_pos.w > 1e-6f ? load_sh_as_rgb(sh_coeffs, _shs[cell].harmonics) : (float3)0;
        float3 rgb = load_sh_as_rgb(sh_coeffs, _shs[cell].harmonics);
        color += rgb * weight;
        transmittance = transmittance * (1.0 - alpha);

        if (t_1 >= scene_depth) {
            break;
        }

        cell = _adjacency[next_face];
        t_0 = t_1;
    }

    _outTex[id.xy] = float4(lerp(color, src_color.xyz, transmittance), 1);
}


// TODO: move to separate shader

uint _Count;
RWStructuredBuffer<half4> _adjacency_diff_uav;

[numthreads(1024, 1, 1)]
void BuildAdjDiff (uint3 id : SV_DispatchThreadID)
{
    uint cell = id.x;
    if (cell >= _Count)
        return;

    float3 cell_pos = _positions[cell].xyz;

    uint adj_from = cell > 0 ? _adjacency_offset[cell-1] : 0;
    uint adj_to = _adjacency_offset[cell];

    for (uint a = adj_from; a < adj_to; a++) {
        uint adj = _adjacency[a];
        float3 adj_pos = _positions[adj].xyz;
        float3 adj_diff = adj_pos - cell_pos;

        _adjacency_diff_uav[a] = half4(adj_diff, 0);
    }
}