#pragma kernel BuildAdjDiff
#pragma kernel RadFoam

float4x4 _Camera2WorldMatrix;
float4x4 _InverseProjectionMatrix;

Texture2D<float4> _srcTex;
RWTexture2D<float4> _outTex;

float2 GetPixelCoords(uint2 id)
{
    uint w, h;
    _outTex.GetDimensions(w, h);
    return id / float2(w, h) * 2 - 1;
}

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray GetCameraRay(float2 pixelCoords)
{
    Ray o;
    o.origin       = mul(_Camera2WorldMatrix, float4(0,0,0,1)).xyz; 
    float3 fragPos = mul(_InverseProjectionMatrix, float4(pixelCoords,0,1)).xyz; 
    o.direction    = normalize( mul(_Camera2WorldMatrix, float4(fragPos,0)).xyz );
    return o;
}

StructuredBuffer<uint> _start_index;
StructuredBuffer<float3> _positions;
StructuredBuffer<float4> _attributes;
StructuredBuffer<uint> _adjacency_offset;
StructuredBuffer<uint> _adjacency;
RWStructuredBuffer<half3> _adjacency_diff;

[numthreads(8,8,1)]
void RadFoam (uint3 id : SV_DispatchThreadID)
{
    float2 pixelCoords = GetPixelCoords(id.xy);
    Ray ray = GetCameraRay(pixelCoords);
    float t_0 = 0.0f;

    float transmittance = 1.0f;
    float3 color = float3(0,0,0);

    uint cell = _start_index[0];
    for (int i = 0; i < 10000 && transmittance > 0.1; i++) {
        float3 cell_pos = _positions[cell];
        uint adj_from = _adjacency_offset[cell-1];
        uint adj_to = _adjacency_offset[cell ];

        float t_1 = 3.40282347e38;
        uint closest = cell; 

        for (uint a = adj_from; a < adj_to; a++) {
            uint adj = _adjacency[a];
            float3 adj_pos = _positions[adj];

            float3 normal = adj_pos - cell_pos;
            float denom = dot(normal, ray.direction);

            if (denom <= 0.0) {
                continue;
            }

            float3 mid = (adj_pos + cell_pos) * 0.5f;
            float t = dot(mid - ray.origin, normal) / denom;
            if (t < t_1) {
                t_1 = t;
                closest = adj;
            }
        }

        if (closest == cell) {
            break;
        }

        {
            float4 attr = _attributes[cell];
            float dist = max(0, t_1 - t_0);
            float alpha = 1.0 - exp(-attr.w * dist);
            float weight = transmittance * alpha;
            color += attr.xyz * weight;
            transmittance = transmittance * (1.0 - alpha);
        }

        t_0 = max(t_0, t_1);
        cell = closest;
    };

    _outTex[id.xy] = float4(lerp(color, _srcTex[id.xy].xyz, transmittance), 1);
}

uint _Count;

[numthreads(1024, 1, 1)]
void BuildAdjDiff (uint3 id : SV_DispatchThreadID)
{
    uint cell = id.x;
    if (cell >= _Count)
        return;

    float3 cell_pos = _positions[cell];

    uint adj_from = _adjacency_offset[cell-1];
    uint adj_to = _adjacency_offset[cell];

    for (uint a = adj_from; a < adj_to; a++) {
        uint adj = _adjacency[a];
        float3 adj_pos = _positions[adj];
        float3 adj_diff = adj_pos - cell_pos;

        _adjacency_diff[a] = adj_diff;
    }
}